{
  "code" : "io.liquichain.api.payment.LiquichainPaymentScript",
  "inputs" : [ {
    "name" : "orderId",
    "type" : "String"
  }, {
    "name" : "endpointRequest",
    "type" : "EndpointRequest"
  }, {
    "name" : "endpointResponse",
    "type" : "EndpointResponse"
  } ],
  "outputs" : [ {
    "name" : "result",
    "type" : "String"
  }, {
    "name" : "orderId",
    "type" : "String"
  } ],
  "generateOutputs" : false,
  "type" : "JAVA",
  "transactionType" : "SAME",
  "script" : "package io.liquichain.api.payment;\r\n\r\nimport com.google.gson.Gson;\r\nimport io.liquichain.core.BlockForgerScript;\r\n\r\nimport com.paypal.core.PayPalEnvironment;\r\nimport com.paypal.core.PayPalHttpClient;\r\nimport com.paypal.http.HttpResponse;\r\nimport com.paypal.http.exceptions.HttpException;\r\nimport com.paypal.orders.*;\r\n\r\nimport java.util.*;\r\nimport java.time.Instant;\r\nimport java.math.BigInteger;\r\nimport java.math.BigDecimal;\r\nimport java.io.IOException;\r\n\r\nimport org.apache.commons.collections.CollectionUtils;\r\nimport org.meveo.admin.util.pagination.PaginationConfiguration;\r\nimport org.meveo.commons.utils.StringUtils;\r\nimport org.meveo.model.customEntities.CustomEntityInstance;\r\nimport org.meveo.model.customEntities.CustomEntityTemplate;\r\nimport org.meveo.persistence.CrossStorageService;\r\nimport org.meveo.service.custom.CustomEntityTemplateService;\r\nimport org.meveo.service.custom.NativeCustomEntityInstanceService;\r\nimport org.meveo.api.rest.technicalservice.EndpointScript;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.math.BigInteger;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.customEntities.PaypalOrder;\r\nimport org.meveo.model.customEntities.Transaction;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport com.fasterxml.jackson.core.JsonProcessingException;\r\n\r\nimport org.web3j.crypto.*;\r\n\r\nimport javax.servlet.http.HttpServletRequest;\r\n\r\npublic class LiquichainPaymentScript extends EndpointScript {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(LiquichainPaymentScript.class);\r\n\r\n    private long chainId = 76;\r\n\r\n    private String result;\r\n\r\n    private String orderId = null;\r\n\r\n    private String originWallet = \"212dFDD1Eb4ee053b2f5910808B7F53e3D49AD2f\".toLowerCase();\r\n\r\n    private CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\r\n    private CustomEntityTemplateService customEntityTemplateService = getCDIBean(CustomEntityTemplateService.class);\r\n    private CrossStorageService crossStorageService = getCDIBean(CrossStorageService.class);\r\n\r\n    public String getResult() {\r\n        return result;\r\n    }\r\n\r\n    public void setOrderId(String orderId) {\r\n      \tlog.info(\"orderId setter {}\", orderId);\r\n        this.orderId = orderId;\r\n    }\r\n  \r\n  \tpublic String getOrderId() {\r\n    \treturn orderId;\r\n    }\r\n\r\n    @Override\r\n    public void execute(Map<String, Object> parameters) throws BusinessException {\r\n      \tlog.info(\"orderId from path={}\", getOrderId());\r\n        String message = \"Wallet does not exists\";\r\n        Map<String, Object> from = (Map<String, Object>) parameters.get(\"from\");\r\n        Map<String, Object> to = (Map<String, Object>) parameters.get(\"to\");\r\n        String publicAddress = (String) parameters.get(\"account\");\r\n        String returnUrl = \"https://account.liquichain.io/\";\r\n\t\tlog.info(\"orderId from setter :{}\",orderId);\r\n        String path = this.endpointRequest.getPathInfo();\r\n        if(path.lastIndexOf(\"/\")==16){\r\n        \torderId = path.substring(17);\r\n        }\r\n        log.info(\"execute paymentScript, orderId={}  account=0x{}, path={}, lastIndex:{}\",orderId,publicAddress,path,path.lastIndexOf(\"/\"));\r\n        List<OrderItem> orderItems = new ArrayList<>();\r\n\r\n        if (from != null) {\r\n            OrderItem orderItem = new OrderItem();\r\n            orderItem.setCurrencyCode(\"\" + from.get(\"currency\"));\r\n            orderItem.setValue(\"\" + from.get(\"amount\"));\r\n            orderItems.add(orderItem);\r\n        }\r\n\r\n        Order order = null;\r\n        Gson gson = new Gson();\r\n        OrderService orderService = new OrderService();\r\n\r\n        if (orderId == null || orderId.equals(\"0\")) {\r\n            if (StringUtils.isNotBlank(publicAddress)) {\r\n                try {\r\n                    Wallet toWallet = crossStorageApi.find(defaultRepo, Wallet.class).by(\"hexHash\", publicAddress.toLowerCase()).getResult();\r\n                    Wallet fromWallet = crossStorageApi.find(defaultRepo, Wallet.class).by(\"hexHash\", originWallet).getResult();\r\n                    BigInteger amount = new BigDecimal(to.get(\"amount\").toString()).movePointRight(18).toBigInteger();\r\n\t\t\t\t    BigInteger originBalance = new BigInteger(fromWallet.getBalance());\r\n        \t\t\tlog.info(\"originWallet 0x{} old balance:{} amount:{}\",originWallet,fromWallet.getBalance(),amount);\r\n        \t\t\tif(amount.compareTo(originBalance)<=0){\r\n                      \tlog.info(\"create paypal order\");\r\n                        order = orderService.createOrder(orderItems, returnUrl);\r\n                      \tlog.info(\"return orderId :{}\",order.id());\r\n                        PaypalOrder paypalOrder = new PaypalOrder();\r\n                        paypalOrder.setCreationDate(Instant.now());\r\n                        paypalOrder.setOrderId(order.id());\r\n                        paypalOrder.setFromWallet(originWallet);\r\n                        paypalOrder.setFromCurrency(from.get(\"currency\").toString());\r\n                        paypalOrder.setFromAmount(from.get(\"amount\").toString());\r\n                        paypalOrder.setToWallet(publicAddress);\r\n                        //FIXME; use conversion rate\r\n                        paypalOrder.setToCurrency(to.get(\"currency\").toString());\r\n                        paypalOrder.setToAmount(to.get(\"amount\").toString());\r\n                \t\tpaypalOrder.setStatus(\"CREATED\");\r\n        \t\t\t\tcrossStorageApi.createOrUpdate(defaultRepo, paypalOrder);\r\n                        result = gson.toJson(order);\r\n                      \tlog.info(\"persisted paypalOrder, result order:{}\",result);\r\n        \t\t\t} else {\r\n                      \tlog.error(\"Insufficient global balance\");\r\n                        result = createErrorResponse(null, \"501\", \"Insufficient global balance\");\r\n                    }\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                    result = createErrorResponse(null, \"-32700\", e.getMessage());\r\n                }\r\n            } else {\r\n                log.error(\"account publicAddress:{}\",publicAddress);\r\n                result = createErrorResponse(null, \"404\", message);\r\n            }\r\n        } else {\r\n            log.info(\"capture {}\",orderId);\r\n            order = orderService.captureOrder(orderId);\r\n\t\t\tPaypalOrder paypalOrder = crossStorageApi.find(defaultRepo, PaypalOrder.class).by(\"orderId\", orderId).getResult();\r\n            if (order == null || paypalOrder==null) {\r\n                message = \"Cannot capture order:\"+orderId;\r\n                if(paypalOrder!=null){\r\n                \tpaypalOrder.setStatus(\"KO\");\r\n                    paypalOrder.setError(message);\r\n                    try{\r\n        \t\t\t\tcrossStorageApi.createOrUpdate(defaultRepo, paypalOrder);\r\n                    } catch (Exception e){\r\n                      e.printStackTrace();\r\n                    }\r\n                }\r\n                result = createErrorResponse(orderId, \"406\", message);\r\n            } else if (StringUtils.isNotBlank(order.status()) && \"COMPLETED\".equalsIgnoreCase(order.status())) {\r\n                Transaction transac = new Transaction();\r\n        \t\ttransac.setHexHash(orderId);\r\n        \t\ttransac.setFromHexHash(originWallet);\r\n        \t\ttransac.setToHexHash(paypalOrder.getToWallet());\r\n        \t\t\r\n        \t\t//FIXME: increment the nonce\r\n        \t\ttransac.setNonce(\"1\");\r\n      \r\n        \t\ttransac.setGasPrice(\"0\");\r\n        \t\ttransac.setGasLimit(\"0\");\r\n        \t\ttransac.setValue(paypalOrder.getToAmount());\r\n              \r\n        \t\t//FIXME: sign the transaction\r\n        \t\ttransac.setSignedHash(UUID.randomUUID().toString());\r\n              \r\n        \t\ttransac.setCreationDate(java.time.Instant.now());\r\n                try {\r\n        \t\t\tcrossStorageApi.createOrUpdate(defaultRepo, transac);\r\n\r\n                \t//FIXME: you should get the BlockForgerScript from scriptService\r\n        \t\t\tBlockForgerScript.addTransaction(transac);\r\n                    paypalOrder.setStatus(\"OK\");\r\n                  \ttry {\r\n        \t\t   \t\tcrossStorageApi.createOrUpdate(defaultRepo, paypalOrder);\r\n               \t\t} catch(Exception ex){\r\n                  \t\tex.printStackTrace();\r\n                \t}\r\n                    result = \"Success\";\r\n                    result = createResponse(orderId, null);\r\n                } catch(Exception e){\r\n                    log.error(\"Paypal ok but transaction ko:{}\",order);\r\n                    message = \"Transaction error:\"+e.getMessage();\r\n                \tpaypalOrder.setStatus(\"ALERT\");\r\n                \tpaypalOrder.setError(message);\r\n                \ttry{\r\n        \t\t\t\tcrossStorageApi.createOrUpdate(defaultRepo, paypalOrder);\r\n                \t} catch (Exception ex){\r\n                    \te.printStackTrace();\r\n                \t}\r\n                \tresult = createErrorResponse(orderId, \"406\", message);\r\n                }\r\n\r\n            } else {\r\n                message = \"Capture failed:\"+order.status();\r\n                paypalOrder.setStatus(\"KO\");\r\n                paypalOrder.setError(message);\r\n                try{\r\n        \t\t\tcrossStorageApi.createOrUpdate(defaultRepo, paypalOrder);\r\n                } catch (Exception e){\r\n                    e.printStackTrace();\r\n                }\r\n                result = createErrorResponse(orderId, \"406\", message);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    private String createResponse(String requestId, Order order) {\r\n        String res = \"{\\n\";\r\n        res += \"  \\\"id\\\": \\\"\" + requestId + \"\\\",\\n\";\r\n        res += \"  \\\"status\\\": \\\"\" + 200 + \"\\\",\\n\";\r\n       // res += \"  \\\"jsonrpc\\\": \\\"2.0\\\",\\n\";\r\n        if (order != null) {\r\n            try {\r\n                res += \"  \\\"result\\\": \" + new ObjectMapper().writeValueAsString(order) + \"\\n\";\r\n            } catch (JsonProcessingException jpe) {\r\n                // used error code from https://github.com/claudijo/json-rpc-error\r\n                return createErrorResponse(requestId, \"-32700\", jpe.getMessage());\r\n            }\r\n        } else {\r\n            res += \"  \\\"message\\\": \\\"\" + result + \"\\\"\\n\";\r\n        }\r\n        res += \"}\";\r\n        // log.info(\"res:{}\", res);\r\n        return res;\r\n\r\n    }\r\n\r\n    private String createErrorResponse(String requestId, String errorCode, String message) {\r\n        String res = \"{\\n\";\r\n        if (requestId != null) {\r\n            res += \"  \\\"id\\\": \\\"\"  + requestId + \"\\\",\\n\";\r\n        }\r\n        res += \"  \\\"status\\\": \\\"\" + errorCode + \"\\\",\\n\";\r\n        res += \"  \\\"message\\\": \\\"\" + message + \"\\\"\\n\";\r\n        res += \"}\";\r\n        log.info(\"err:{}\", res);\r\n        return res;\r\n    }\r\n\r\n}\r\n\r\nclass PaypalSandboxClient {\r\n    static String clientId = \"AWVIDI2xMJE0AXDOdEtttOW0WgrLzeNWBUAKClN4bVYXdeP2Hkx3BXPlXOahZs0palbyhcpzrow9ZMg3\";\r\n    static String secret = \"EOHmSfHQQxACD94zzZOBqPXy3ETALxOTdpr-KRLw4ECRs0Bk3olEhn9AQTz922J6o3U5L47Se5x727l_\";\r\n\r\n    private static PayPalEnvironment environment = new PayPalEnvironment.Sandbox(clientId, secret);\r\n    static PayPalHttpClient client = new PayPalHttpClient(environment);\r\n}\r\n\r\nclass PaypalLiveClient {\r\n    static String clientId = \"PRODUCTION-CLIENT-ID\";\r\n    static String secret = \"PRODUCTION-CLIENT-SECRET\";\r\n    private static PayPalEnvironment environment = new PayPalEnvironment.Live(clientId, secret);\r\n    static PayPalHttpClient client = new PayPalHttpClient(environment);\r\n}\r\n\r\nclass OrderItem {\r\n    private String currencyCode;\r\n    private String value;\r\n\r\n    public String getCurrencyCode() {\r\n        return currencyCode;\r\n    }\r\n\r\n    public void setCurrencyCode(String currencyCode) {\r\n        this.currencyCode = currencyCode;\r\n    }\r\n\r\n    public String getValue() {\r\n        return value;\r\n    }\r\n\r\n    public void setValue(String value) {\r\n        this.value = value;\r\n    }\r\n}\r\n\r\nclass OrderService {\r\n    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);\r\n    private PayPalHttpClient client = null;\r\n    private boolean debug = false;\r\n\r\n    public OrderService() {\r\n        this.client = PaypalSandboxClient.client;\r\n        this.debug = true;\r\n    }\r\n\r\n    public OrderService(String type) {\r\n        if (\"PRODUCTION\".equals(type)) {\r\n            this.client = PaypalLiveClient.client;\r\n        } else {\r\n            this.client = PaypalSandboxClient.client;\r\n            this.debug = true;\r\n        }\r\n    }\r\n\r\n    public PayPalHttpClient getClient() {\r\n        return client;\r\n    }\r\n\r\n    public void setClient(PayPalHttpClient client) {\r\n        this.client = client;\r\n    }\r\n\r\n    public Order createOrder(List<OrderItem> orderItems, String returnUrl) {\r\n        Order order = null;\r\n        boolean hasOrderItems = orderItems != null && !orderItems.isEmpty();\r\n        if (hasOrderItems) {\r\n            OrderRequest orderRequest = new OrderRequest();\r\n            orderRequest.checkoutPaymentIntent(\"CAPTURE\");\r\n\r\n            List<PurchaseUnitRequest> purchaseUnits = new ArrayList<>();\r\n\r\n            orderItems.stream().forEach((item) -> purchaseUnits.add(new PurchaseUnitRequest()\r\n                    .amountWithBreakdown(new AmountWithBreakdown().currencyCode(item.getCurrencyCode()).value(item.getValue()))));\r\n\r\n            orderRequest.purchaseUnits(purchaseUnits);\r\n\r\n            ApplicationContext appContext = new ApplicationContext();\r\n            appContext.returnUrl(returnUrl);\r\n            appContext.cancelUrl(returnUrl);\r\n            orderRequest.applicationContext(appContext);\r\n\r\n            OrdersCreateRequest request = new OrdersCreateRequest().requestBody(orderRequest);\r\n\r\n            try {\r\n                HttpResponse<Order> response = this.client.execute(request);\r\n\r\n                order = response.result();\r\n\r\n                if (this.debug) {\r\n                    logger.debug(\"Order ID: \" + order.id());\r\n                    order.links().forEach(link -> logger.debug(link.rel() + \" => \" + link.method() + \":\" + link.href()));\r\n                }\r\n\r\n            } catch (IOException ioe) {\r\n                if (ioe instanceof HttpException) {\r\n                    logger.error(\"Failed to create order.\", ioe);\r\n                } else {\r\n                    logger.error(\"Unknown error while creating order.\", ioe);\r\n                }\r\n            }\r\n        } else {\r\n            logger.warn(\"No order details provided, will not process creation of order.\");\r\n        }\r\n        return order;\r\n    }\r\n\r\n    public Order captureOrder(String orderId) {\r\n        Order order = null;\r\n        OrdersCaptureRequest request = new OrdersCaptureRequest(orderId);\r\n\r\n        try {\r\n            HttpResponse<Order> response = this.client.execute(request);\r\n\r\n            order = response.result();\r\n\r\n            if (this.debug) {\r\n                logger.debug(\"Status Code: \" + response.statusCode());\r\n                logger.debug(\"Status: \" + order.status());\r\n                logger.debug(\"Order ID: \" + order.id());\r\n                logger.debug(\"Links: \");\r\n                for (LinkDescription link : order.links()) {\r\n                    logger.debug(\"\\t\" + link.rel() + \": \" + link.href());\r\n                }\r\n                logger.debug(\"Capture ids:\");\r\n                for (PurchaseUnit purchaseUnit : order.purchaseUnits()) {\r\n                    for (Capture capture : purchaseUnit.payments().captures()) {\r\n                        logger.debug(\"\\t\" + capture.id());\r\n                    }\r\n                }\r\n            }\r\n\r\n        } catch (IOException ioe) {\r\n            if (ioe instanceof HttpException) {\r\n                logger.error(\"Failed to capture order.\", ioe);\r\n            } else {\r\n                logger.error(\"Unknown error while capturing order.\", ioe);\r\n            }\r\n        }\r\n        return order;\r\n    }\r\n}",
  "executionRoles" : [ ],
  "sourcingRoles" : [ ],
  "mavenDependencies" : [ {
    "groupId" : "com.paypal.sdk",
    "artifactId" : "checkout-sdk",
    "version" : "1.0.3",
    "coordinates" : "com.paypal.sdk:checkout-sdk:1.0.3"
  } ],
  "importScriptInstances" : [ {
    "code" : "io.liquichain.core.BlockForgerScript",
    "description" : "Bock forging script",
    "inputs" : [ ],
    "outputs" : [ {
      "name" : "lastBlock",
      "type" : "Block"
    } ],
    "generateOutputs" : false,
    "type" : "JAVA",
    "transactionType" : "SAME",
    "script" : "package io.liquichain.core;\r\n\r\nimport java.util.Map;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Arrays;\r\nimport java.util.ArrayList;\r\nimport java.math.BigInteger;\r\nimport java.time.Instant;\r\nimport java.util.concurrent.atomic.AtomicBoolean;\r\nimport java.util.stream.Collectors;\r\nimport java.io.IOException;\r\nimport org.meveo.service.script.Script;\r\nimport org.meveo.admin.exception.BusinessException;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport java.math.BigInteger;\r\nimport org.meveo.model.customEntities.Block;\r\nimport org.meveo.model.customEntities.Wallet;\r\nimport org.meveo.model.customEntities.Transaction;\r\nimport org.meveo.model.storage.Repository;\r\nimport org.meveo.service.storage.RepositoryService;\r\nimport org.meveo.api.persistence.CrossStorageApi;\r\nimport org.meveo.persistence.CrossStorageService;\r\nimport org.meveo.cache.CustomFieldsCacheContainerProvider;\r\nimport org.meveo.api.exception.EntityDoesNotExistsException;\r\nimport org.meveo.admin.util.pagination.PaginationConfiguration;\r\nimport org.meveo.model.persistence.CEIUtils;\r\nimport org.meveo.service.custom.CustomTableService;\r\nimport com.fasterxml.jackson.databind.ObjectMapper;\r\nimport org.primefaces.model.SortOrder;\r\n\r\nimport org.web3j.crypto.*;\r\n\r\npublic class BlockForgerScript extends Script {\r\n\r\n    private static final Logger log = LoggerFactory.getLogger(BlockForgerScript.class);\r\n  \r\n    private static long chainId=76;\r\n\r\n    private int networkId = 7;\r\n\r\n    static public long blockHeight = 1662295;\r\n  \r\n    private Block parentBlock=null;\r\n    \r\n    private String exampleBlock = \"{\" +\r\n      \"\\\"difficulty\\\":\\\"0x5\\\",\" +\r\n      \"\\\"extraData\\\":\\\"0xd58301090083626f7286676f312e3133856c696e75780000000000000000000021c9effaf6549e725463c7877ddebe9a2916e03228624e4bfd1e3f811da792772b54d9e4eb793c54afb4a29f014846736755043e4778999046d0577c6e57e72100\\\",\"\r\n      + \"\\\"gasLimit\\\":\\\"0xe984c2\\\",\" + \"\\\"gasUsed\\\":\\\"0x0\\\",\" \r\n      + \"\\\"hash\\\":\\\"0xaa14340feb15e26bc354bb839b2aa41cc7984676249c155ac5e4d281a8d08809\\\",\"\r\n      + \"\\\"logsBloom\\\":\\\"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\\\",\"\r\n      + \"\\\"miner\\\":\\\"0x0000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"mixHash\\\":\\\"0x0000000000000000000000000000000000000000000000000000000000000000\\\",\" +\r\n      \"\\\"nonce\\\":\\\"0x0000000000000000\\\",\" +\r\n      \"\\\"number\\\":\\\"0x1b4\\\",\" +\r\n      \"\\\"parentHash\\\":\\\"0xc8ccb81f484a428a3a1669d611f55f880b362b612f726711947d98f5bc5af573\\\",\" + \r\n      \"\\\"receiptsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" +\r\n      \"\\\"sha3Uncles\\\":\\\"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\\\",\" +\r\n      \"\\\"size\\\":\\\"0x260\\\",\" +\r\n      \"\\\"stateRoot\\\":\\\"0xffcb834d62706995e9e7bf10cc9a9e42a82fea998d59b3a5cfad8975dbfe3f87\\\",\" +\r\n      \"\\\"timestamp\\\":\\\"0x5ed9a43f\\\",\" +\r\n      \"\\\"totalDifficulty\\\":\\\"0x881\\\",\" +\r\n      \"\\\"transactions\\\":[\" + \"],\" + \r\n      \"\\\"transactionsRoot\\\":\\\"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\\\",\" + \r\n      \"\\\"uncles\\\":[  \" + \"]}\";\r\n\r\n      \r\n\tprivate CustomFieldsCacheContainerProvider cetCache = getCDIBean(CustomFieldsCacheContainerProvider.class);\r\n    private CrossStorageService crossStorageService = getCDIBean(CrossStorageService.class);\r\n    private CustomTableService customTableService = getCDIBean(CustomTableService.class);\r\n    \r\n    private static PaginationConfiguration lastBlockPC = new PaginationConfiguration(\"blockNumber\",SortOrder.DESCENDING);\r\n  \r\n  \tprivate CrossStorageApi crossStorageApi = getCDIBean(CrossStorageApi.class);\r\n    private RepositoryService repositoryService = getCDIBean(RepositoryService.class);\r\n    private Repository defaultRepo = repositoryService.findDefaultRepository();\r\n\r\n    \r\n    private static List<Transaction> currentTransactions = new ArrayList<>();\r\n    private static List<Transaction> nextTransactions = new ArrayList<>();\r\n  \r\n    private static Instant nextBlockDate;\r\n    private static AtomicBoolean isForging = new AtomicBoolean(false);\r\n  \r\n    public static void addTransaction(Transaction t){\r\n      if(isForging.get()){\r\n          nextTransactions.add(t);\r\n      } else {\r\n          currentTransactions.add(t);\r\n      }\r\n    }\r\n  \r\n    public Block getLastBlock(){\r\n        Block result = null;\r\n        try{\r\n            //log.info(\"query : \"+customTableService.getQuery(\"block\", lastBlockPC));\r\n        List<Map<String, Object>> res = crossStorageService.find(defaultRepo, cetCache.getCustomEntityTemplate(\"Block\"), lastBlockPC);\r\n        if(res.size()>0){\r\n            result = CEIUtils.deserialize(res.get(0), Block.class);\r\n            //log.info(\"lastBlock number:{}\",result.getBlockNumber());\r\n        }\r\n        } catch(Exception e){\r\n          log.error(\"getLastBlock:{}\",e);\r\n        }\r\n        return result;\r\n    }\r\n  \r\n    @Override\r\n    public void execute(Map<String, Object> parameters) throws BusinessException {\r\n      //log.info(\"execute forging\");\r\n      if(parentBlock==null){\r\n      \t//log.info(\"retreive last block from chain\");\r\n        parentBlock = getLastBlock();\r\n      }\r\n      if(isForging.getAndSet(true)){\r\n         log.error(\"we are already forging\");\r\n         return;\r\n      } \r\n      if(currentTransactions.size()==0){\r\n       // log.info(\"no transaction to forge\");\r\n        isForging.set(false);\r\n        return;\r\n      } else {\r\n        //log.info(\"forging {} transactions\",currentTransactions.size());\r\n        Map<String,Wallet> wallets = new HashMap<>();\r\n        List<Transaction> orderedTransactions = currentTransactions.stream().sorted((t1,t2)->(t1.getCreationDate().compareTo(t2.getCreationDate()))).collect(Collectors.toList());\r\n        \r\n        blockHeight=parentBlock.getBlockNumber()+1;\r\n        \r\n        String transactionHashes=\"\";\r\n        List<Transaction> invalidTransactions = new ArrayList<>();\r\n        for(Transaction t: currentTransactions){\r\n          log.info(\" transaction date : {}\",t.getCreationDate());\r\n          if(!wallets.containsKey(t.getFromHexHash())){\r\n            try{\r\n            \tWallet originWallet = crossStorageApi.find(defaultRepo,t.getFromHexHash(), Wallet.class);\r\n                log.info(\"add originWallet:{} {} to map\",originWallet.getUuid(),originWallet.getBalance());\r\n                wallets.put(t.getFromHexHash(),originWallet);\r\n            } catch(Exception e){\r\n              log.info(\" cannot find origin wallet, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try {\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n          if(t.getBlockNumber() == null){\r\n            Wallet originWallet = wallets.get(t.getFromHexHash());\r\n          \tlog.info(\"originWallet 0x{} old balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n            BigInteger transacValue = new BigInteger(t.getValue());\r\n          \tif(new BigInteger(originWallet.getBalance()).compareTo(transacValue)>=0){\r\n                originWallet.setBalance(\"\"+new BigInteger(originWallet.getBalance()).add(transacValue.negate()));\r\n                try{\r\n            \t\tWallet destinationWallet = crossStorageApi.find(defaultRepo,t.getToHexHash(), Wallet.class);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} old balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n                    destinationWallet.setBalance(\"\"+new BigInteger(destinationWallet.getBalance()).add(transacValue));\r\n          \t\t\tcrossStorageApi.createOrUpdate(defaultRepo, destinationWallet);\r\n          \t\t\tlog.info(\"destinationWallet 0x{} new balance:{}\",t.getToHexHash(),destinationWallet.getBalance());\r\n          \t\t\ttransactionHashes+=t.getHexHash();\r\n                } catch(Exception e){\r\n              \t\tlog.info(\" cannot find destination wallet, set blockNumber to INVALID\");\r\n              \t\tt.setBlockNumber(\"INVALID\");\r\n              \t\ttry{\r\n\t\t\t\t\t\tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n                    } catch(Exception ex){\r\n                \t\tex.printStackTrace();\r\n              \t\t}\r\n              \t\tinvalidTransactions.add(t);\r\n                }\r\n          \t} else {\r\n              log.info(\"insufficient balance, set blockNumber to INVALID\");\r\n              t.setBlockNumber(\"INVALID\");\r\n              try{\r\n              \tcrossStorageApi.createOrUpdate(defaultRepo, t);\r\n              } catch(Exception ex){\r\n                ex.printStackTrace();\r\n              }\r\n              invalidTransactions.add(t);\r\n            }\r\n          }\r\n        }\r\n        currentTransactions.removeAll(invalidTransactions);\r\n        Block block =  new Block();\r\n        block.setCreationDate(Instant.now());\r\n        \r\n        //FIXME parent should not be null\r\n        block.setParentHash(parentBlock==null?\"\":parentBlock.getHash());\r\n        block.setSize((long)currentTransactions.size());\r\n        \r\n        //FIXME hash parent hash\r\n        block.setHash(Hash.sha3(transactionHashes).substring(2));\r\n        \r\n        block.setBlockNumber(blockHeight);\r\n        try{\r\n          crossStorageApi.createOrUpdate(defaultRepo, block);\r\n          long i=0;\r\n          for(Transaction t: currentTransactions){\r\n              Wallet originWallet = wallets.get(t.getFromHexHash());\r\n              log.info(\"originWallet 0x{} new balance:{}\",t.getFromHexHash(),originWallet.getBalance());\r\n              crossStorageApi.createOrUpdate(defaultRepo, originWallet);\r\n              t.setBlockHash(block.getHash());\r\n              t.setBlockNumber(\"\"+block.getBlockNumber());\r\n              t.setTransactionIndex(i++);\r\n              crossStorageApi.createOrUpdate(defaultRepo, t);\r\n          }\r\n\r\n          parentBlock=block;\r\n          currentTransactions = nextTransactions;\r\n          nextTransactions = new ArrayList<>();\r\n        } catch(Exception ex){\r\n            ex.printStackTrace();\r\n        }\r\n        \r\n        isForging.set(false);\r\n      }\r\n    }\r\n  \r\n}",
    "executionRoles" : [ ],
    "sourcingRoles" : [ ],
    "mavenDependencies" : [ {
      "groupId" : "org.web3j",
      "artifactId" : "crypto",
      "version" : "4.8.9",
      "coordinates" : "org.web3j:crypto:4.8.9"
    } ],
    "importScriptInstances" : [ ]
  } ]
}